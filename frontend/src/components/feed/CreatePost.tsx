import React, { useState, useRef, useEffect } from 'react';
import axios from 'axios';
import { useApolloClient } from '@apollo/client';
import { useAuth } from '../../contexts/AuthContext';
import MediaPreview from './MediaPreview';
import MediaButtons from './MediaButtons';
import LocationDisplay from '../Location/LocationDisplay';
import { LocationPicker, type LocationData } from '../common/LocationPicker';
// We only need to import the hooks and types generated by the codegen.
import {
  useCreatePostMutation,
  GetPostsDocument,
  GetPostsQuery,
} from '../../gql/generated';

interface LocationResult {
  name: string;
  address: string;
  lat: number;
  lng: number;
  placeId: string;
}

export function CreatePost() {
  const [content, setContent] = useState('');
  const [previews, setPreviews] = useState<string[]>([]);
  const [selectedImage, setSelectedImage] = useState<File | null>(null);
  const [selectedVideo, setSelectedVideo] = useState<File | null>(null);
  const [selectedLocation, setSelectedLocation] = useState<LocationResult | null>(null);
  const [isLocationSearchOpen, setIsLocationSearchOpen] = useState(false);
  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [uploadError, setUploadError] = useState<string | null>(null);
  const [isExpanded, setIsExpanded] = useState(false);
  const imageInputRef = useRef<HTMLInputElement>(null);
  const videoInputRef = useRef<HTMLInputElement>(null);
  const createPostRef = useRef<HTMLDivElement>(null);
  const apolloClient = useApolloClient();
  const { user } = useAuth();
  const maxCaptionLength = 500;

  // Add animation styles
  useEffect(() => {
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    `;
    document.head.appendChild(style);
    return () => {
      document.head.removeChild(style);
    };
  }, []);

  // Handle click outside to collapse
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (createPostRef.current && !createPostRef.current.contains(event.target as Node) && isExpanded) {
        // Only collapse if there's no content to avoid losing work
        if (!content.trim() && !selectedImage && !selectedVideo && !selectedLocation) {
          handleCollapse();
        }
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isExpanded, content, selectedImage, selectedVideo, selectedLocation]);
  
  // The generated hook already knows what mutation to run.
  const [, { loading, error }] = useCreatePostMutation({
    update(cache, { data: mutationResult }) {
      const newPost = mutationResult?.createPost;
      if (!newPost) return;

      const existingData = cache.readQuery<GetPostsQuery>({
        query: GetPostsDocument,
      });

      if (existingData?.posts) {
        cache.writeQuery({
          query: GetPostsDocument,
          data: { posts: [newPost, ...existingData.posts] },
        });
      }
    }
  });

  const handleImageSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setSelectedImage(file);
      setSelectedVideo(null);
      const preview = URL.createObjectURL(file);
      setPreviews([preview]);
    }
  };

  const validateVideo = (file: File): string | null => {
    const validTypes = ['video/mp4', 'video/mov', 'video/quicktime', 'video/webm'];
    const maxSize = 100 * 1024 * 1024; // 100MB
    
    if (!validTypes.includes(file.type)) {
      return `Invalid video format. Please upload MP4, MOV, or WebM files only.`;
    }
    
    if (file.size > maxSize) {
      return `File too large. Please upload videos smaller than 100MB.`;
    }
    
    return null;
  };

  const handleVideoSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      // üîß VALIDATION: Check file type and size
      const validationError = validateVideo(file);
      if (validationError) {
        alert(validationError);
        e.target.value = ''; // Reset input
        return;
      }

      setSelectedVideo(file);
      setSelectedImage(null);
      const preview = URL.createObjectURL(file);
      setPreviews([preview]);
      if (import.meta.env.DEV) {
        console.log('‚úÖ VIDEO_VALIDATION: Valid video selected', {
          name: file.name,
          type: file.type,
          size: `${(file.size / 1024 / 1024).toFixed(2)}MB`
        });
      }
    }
  };

  const removeMedia = () => {
    previews.forEach(preview => URL.revokeObjectURL(preview));
    setSelectedImage(null);
    setSelectedVideo(null);
    setPreviews([]);
    if (imageInputRef.current) imageInputRef.current.value = '';
    if (videoInputRef.current) videoInputRef.current.value = '';
  };

  const removeLocation = () => {
    setSelectedLocation(null);
  };

  const handleLocationSelect = (locationData: LocationData | null) => {
    if (locationData) {
      setSelectedLocation({
        name: locationData.name || 'Unknown Location',
        address: locationData.address || '',
        lat: locationData.latitude,
        lng: locationData.longitude,
        placeId: `${locationData.latitude},${locationData.longitude}` // Generate a simple ID
      });
    } else {
      setSelectedLocation(null);
    }
    setIsLocationSearchOpen(false);
  };

  const resetForm = () => {
    setContent('');
    removeMedia();
    setSelectedLocation(null);
    setIsLocationSearchOpen(false);
  };

  const handleCollapse = () => {
    setIsExpanded(false);
    // Don't reset form when collapsing - keep the content, media and location
  };

  // Clean up preview URLs on unmount
  React.useEffect(() => {
    return () => {
      previews.forEach(preview => URL.revokeObjectURL(preview));
    };
  }, []);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if ((!content.trim() && !selectedImage && !selectedVideo) || loading || uploading) return;

    try {
      setUploading(true);
      setUploadError(null);
      setUploadProgress(0);
      
      // üîß VALIDATION: Check content or media exists
      if (!content.trim() && !selectedImage && !selectedVideo) {
        setUploadError('Please add some content, image, or video to your post');
        return;
      }
      
      // Create a REST endpoint for now since GraphQL file upload is complex
      const formData = new FormData();
      formData.append('content', content);
      
      // Add video/image support - videos go in separate field for backend processing
      if (selectedImage) {
        formData.append('images', selectedImage);
        if (import.meta.env.DEV) {
          console.log('üì∏ UPLOAD: Adding image to form data');
        }
      } else if (selectedVideo) {
        formData.append('videos', selectedVideo);
        if (import.meta.env.DEV) {
          console.log('üé¨ UPLOAD: Adding video to form data', {
            name: selectedVideo.name,
            type: selectedVideo.type,
            size: selectedVideo.size
          });
        }
      }
      
      // Add location data if selected
      if (selectedLocation) {
        formData.append('location', JSON.stringify({
          name: selectedLocation.name,
          address: selectedLocation.address,
          latitude: selectedLocation.lat,
          longitude: selectedLocation.lng
        }));
      }

      // Add video settings for Instagram-style behavior
      if (selectedVideo) {
        formData.append('videoSettings', JSON.stringify({
          autoplay: false, // Let VideoPlayer handle autoplay based on viewport
          loop: true,
          muted: true
        }));
      }

      if (import.meta.env.DEV) {
        console.log('üöÄ UPLOAD: Starting post upload with:', {
          hasContent: !!content.trim(),
          hasImage: !!selectedImage,
          hasVideo: !!selectedVideo,
          hasLocation: !!selectedLocation
        });
      }
      
      const token = localStorage.getItem('passport_buddy_token');
      const response = await axios.post(`${import.meta.env.VITE_API_URL}/api/v1/posts`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
          'Authorization': token ? `Bearer ${token}` : '',
        },
        onUploadProgress: (progressEvent) => {
          if (progressEvent.total) {
            const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);
            setUploadProgress(progress);
            if (import.meta.env.DEV) {
              console.log(`üìä UPLOAD_PROGRESS: ${progress}%`);
            }
          }
        },
      });

      if (import.meta.env.DEV) {
        console.log('‚úÖ UPLOAD: Upload successful:', response.data);
      }

      // Trigger a refresh of the feed by dispatching a custom event
      window.dispatchEvent(new CustomEvent('post-created'));

      // Reset form after successful post
      resetForm();
      
      // Then collapse the form
      setIsExpanded(false);
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error('‚ùå UPLOAD: Failed to create post:', error);
      }
      
      // üîß ERROR_HANDLING: Provide specific error messages
      let errorMessage = 'Failed to create post';
      if (axios.isAxiosError(error)) {
        if (import.meta.env.DEV) {
          console.error('‚ùå UPLOAD: Response:', error.response?.data);
        }
        if (error.code === 'NETWORK_ERROR') {
          errorMessage = 'Network error. Please check your internet connection.';
        } else if (error.response?.status === 413) {
          errorMessage = 'File too large. Please reduce file size and try again.';
        } else if (error.response?.status === 400) {
          errorMessage = error.response?.data?.message || 'Invalid file or content.';
        } else if (error.response?.status === 401) {
          errorMessage = 'You need to log in to create posts.';
        } else {
          errorMessage = error.response?.data?.message || error.message || errorMessage;
        }
      }
      
      setUploadError(errorMessage);
    } finally {
      setUploading(false);
      setUploadProgress(0);
    }
  };

  return (
    <div 
      ref={createPostRef}
      style={{ 
        backgroundColor: 'var(--pb-white)', 
        borderRadius: '12px', 
        padding: '0.75rem', 
        marginBottom: '1rem', 
        border: '1px solid var(--pb-light-periwinkle)',
        transition: 'all 0.2s ease',
        boxShadow: '0 1px 2px rgba(0, 0, 0, 0.04)'
      }}>
      <form onSubmit={handleSubmit}>
        <div style={{ display: 'flex', gap: '0.5rem' }}>
          <div 
            style={{
              width: '32px',
              height: '32px'
            }}
          >
            {user?.avatar ? (
              <img
                src={user.avatar}
                alt={`${user.username}'s avatar`}
                style={{
                  width: '32px',
                  height: '32px',
                  borderRadius: '50%',
                  objectFit: 'cover'
                }}
              />
            ) : (
              <div 
                style={{
                  width: '32px',
                  height: '32px',
                  borderRadius: '50%',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  color: 'white',
                  fontWeight: '600',
                  fontSize: '14px',
                  backgroundColor: 'var(--pb-medium-purple)'
                }}
              >
                {(() => {
                  const fullName = user?.fullName || user?.username || 'User';
                  const names = fullName.split(' ');
                  if (names.length > 1) {
                    return `${names[0].charAt(0)}${names[names.length - 1].charAt(0)}`.toUpperCase();
                  }
                  return fullName.charAt(0).toUpperCase();
                })()}
              </div>
            )}
          </div>

          <div style={{ flex: '1' }}>
            <div style={{ fontWeight: '600', color: '#000', fontSize: '0.813rem', marginBottom: '6px' }}>
              {user?.username || 'User'}
            </div>
            
            <textarea
              value={content}
              onChange={(e) => setContent(e.target.value)}
              placeholder="What's new?"
              onFocus={() => setIsExpanded(true)}
              style={{
                width: '100%',
                backgroundColor: 'transparent',
                border: 'none',
                outline: 'none',
                color: '#000',
                fontSize: '0.813rem',
                resize: 'none',
                minHeight: isExpanded ? '80px' : '32px',
                fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                lineHeight: '1.5',
                transition: 'min-height 0.2s ease'
              }}
              maxLength={maxCaptionLength}
              disabled={uploading}
            />

            {content.length > 400 && (
              <div style={{ textAlign: 'right', fontSize: '0.688rem', color: content.length > 450 ? '#ef4444' : '#9ca3af', marginTop: '0.25rem' }}>
                {content.length}/{maxCaptionLength}
              </div>
            )}

            <MediaPreview
              previewUrl={previews[0] || null}
              selectedImage={selectedImage}
              selectedVideo={selectedVideo}
              onRemoveMedia={removeMedia}
              isLoading={uploading}
            />

            {selectedLocation && (
              <LocationDisplay
                selectedCity={selectedLocation}
                onRemoveLocation={removeLocation}
                isLoading={uploading}
              />
            )}

            {/* üîß ERROR_FEEDBACK: Show upload progress and errors */}
            {uploadError && (
              <div style={{
                backgroundColor: '#fee2e2',
                color: '#dc2626',
                padding: '0.75rem',
                borderRadius: '6px',
                fontSize: '0.875rem',
                marginTop: '0.75rem',
                border: '1px solid #fecaca'
              }}>
                ‚ùå {uploadError}
              </div>
            )}

            {uploading && (
              <div style={{
                backgroundColor: '#eff6ff',
                color: '#1d4ed8',
                padding: '0.75rem',
                borderRadius: '6px',
                fontSize: '0.875rem',
                marginTop: '0.75rem',
                border: '1px solid #bfdbfe'
              }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                  <div style={{
                    width: '16px',
                    height: '16px',
                    border: '2px solid #bfdbfe',
                    borderTop: '2px solid #1d4ed8',
                    borderRadius: '50%',
                    animation: 'spin 1s linear infinite'
                  }}></div>
                  Uploading... {uploadProgress}%
                </div>
                <div style={{
                  width: '100%',
                  backgroundColor: '#bfdbfe',
                  borderRadius: '4px',
                  height: '4px',
                  marginTop: '0.5rem',
                  overflow: 'hidden'
                }}>
                  <div style={{
                    width: `${uploadProgress}%`,
                    backgroundColor: '#1d4ed8',
                    height: '100%',
                    transition: 'width 0.3s ease'
                  }}></div>
                </div>
              </div>
            )}

            {isExpanded && (
              <>
                <MediaButtons
                  onImageClick={() => imageInputRef.current?.click()}
                  onVideoClick={() => videoInputRef.current?.click()}
                  onLocationClick={(e) => {
                    e.preventDefault();
                    setIsLocationSearchOpen(true); // Always open, never toggle
                  }}
                  isLocationSearchOpen={isLocationSearchOpen}
                  selectedLocation={selectedLocation}
                  onLocationSelect={setSelectedLocation}
                  onLocationSearchClose={() => setIsLocationSearchOpen(false)}
                  onRemoveLocation={removeLocation}
                  isLoading={uploading}
                />

                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  marginTop: '0.75rem',
                  paddingTop: '0.75rem',
                  borderTop: '1px solid #f0f0f0'
                }}>
                  <div style={{ fontSize: '0.75rem', color: '#999' }}>
                    Anyone can reply
                  </div>
                  <div style={{ display: 'flex', gap: '0.5rem' }}>
                    <button
                      type="button"
                      onClick={handleCollapse}
                      style={{
                        padding: '0.375rem 0.75rem',
                        backgroundColor: 'transparent',
                        border: '1px solid var(--pb-light-periwinkle)',
                        borderRadius: '16px',
                        color: 'var(--pb-medium-purple)',
                        fontSize: '0.75rem',
                        fontWeight: '500',
                        cursor: 'pointer',
                        transition: 'all 0.2s ease'
                      }}
                    >
                      Cancel
                    </button>
                    <button
                      type="submit"
                      disabled={loading || uploading || (!content.trim() && !selectedImage && !selectedVideo)}
                      style={{
                        paddingLeft: '1rem',
                        paddingRight: '1rem',
                        paddingTop: '0.375rem',
                        paddingBottom: '0.375rem',
                        backgroundColor: loading || uploading || (!content.trim() && !selectedImage && !selectedVideo) ? 'var(--pb-ultra-light)' : 'var(--pb-medium-purple)',
                        color: loading || uploading || (!content.trim() && !selectedImage && !selectedVideo) ? 'var(--pb-medium-purple)' : 'white',
                        borderRadius: '16px',
                        fontSize: '0.75rem',
                        fontWeight: '500',
                        border: 'none',
                        cursor: loading || uploading || (!content.trim() && !selectedImage && !selectedVideo) ? 'not-allowed' : 'pointer',
                        transition: 'all 0.2s ease'
                      }}
                      onMouseEnter={(e) => {
                        if (!loading && !uploading && (content.trim() || selectedImage || selectedVideo)) {
                          e.currentTarget.style.backgroundColor = 'var(--pb-dark-purple)';
                        }
                      }}
                      onMouseLeave={(e) => {
                        if (!loading && !uploading && (content.trim() || selectedImage || selectedVideo)) {
                          e.currentTarget.style.backgroundColor = 'var(--pb-medium-purple)';
                        }
                      }}
                    >
                      {uploading ? 'Uploading...' : loading ? 'Posting...' : 'Post'}
                    </button>
                  </div>
                </div>
              </>
            )}

            {/* Hidden File Inputs */}
            <input
              type="file"
              accept="image/*"
              style={{ display: 'none' }}
              ref={imageInputRef}
              onChange={handleImageSelect}
            />
            <input
              type="file"
              accept="video/*"
              style={{ display: 'none' }}
              ref={videoInputRef}
              onChange={handleVideoSelect}
            />
          </div>
        </div>

        {error && <p style={{ color: '#ef4444', fontSize: '0.75rem', marginTop: '0.375rem' }}>Error: {error.message}</p>}
      </form>

      {/* Location Picker Modal */}
      <LocationPicker
        isOpen={isLocationSearchOpen}
        onClose={() => setIsLocationSearchOpen(false)}
        onLocationSelect={handleLocationSelect}
        initialLocation={selectedLocation ? {
          latitude: selectedLocation.lat,
          longitude: selectedLocation.lng,
          name: selectedLocation.name,
          address: selectedLocation.address
        } : undefined}
      />
    </div>
  );
}