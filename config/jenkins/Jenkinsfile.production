pipeline {
    agent none
    environment {
        // All sensitive values should be stored in Jenkins credentials
        REGISTRY_URL = credentials('docker-registry-url')
        DROPLET_IP   = credentials('production-server-ip')
        DROPLET_USER = credentials('production-server-user')
    }
    stages {
        stage('Checkout') {
            agent any
            steps {
                checkout scm
            }
        }
        
        stage('Validate & Test') {
            agent any
            steps {
                echo 'Running basic validation...'
                sh 'ls -la'
                sh 'test -f api/Dockerfile.prod || exit 1'
                sh 'test -f web/Dockerfile.prod || exit 1'
            }
        }
        
        stage('Build & Push Production Images') {
            agent any
            environment {
                DOCKER_CREDS = credentials('docker-creds')
            }
            steps {
                script {
                    def registry = env.REGISTRY_URL
                    def buildNum = env.BUILD_NUMBER
                    
                    sh "echo \$DOCKER_CREDS_PSW | docker login -u \$DOCKER_CREDS_USR --password-stdin"
                    
                    withCredentials([
                        string(credentialsId: 'vite-api-url', variable: 'VITE_API_URL'),
                        string(credentialsId: 'vite-graphql-url', variable: 'VITE_GRAPHQL_URL')
                    ]) {
                        echo "Building API image..."
                        sh """
                            docker build -f api/Dockerfile.prod \
                                --build-arg NODE_ENV=production \
                                --build-arg API_VERSION=${buildNum} \
                                -t ${registry}/api-app:${buildNum} \
                                -t ${registry}/api-app:latest .
                        """
                        
                        echo "Building Web image..."
                        sh """
                            docker build -f web/Dockerfile.prod \
                                --build-arg VITE_API_URL=${VITE_API_URL} \
                                --build-arg VITE_GRAPHQL_URL=${VITE_GRAPHQL_URL} \
                                -t ${registry}/web-app:${buildNum} \
                                -t ${registry}/web-app:latest .
                        """
                    }
                    
                    echo "Pushing images to registry..."
                    sh "docker push ${registry}/api-app:${buildNum}"
                    sh "docker push ${registry}/api-app:latest"
                    sh "docker push ${registry}/web-app:${buildNum}"
                    sh "docker push ${registry}/web-app:latest"
                    
                    echo "âœ… Docker build and push completed!"
                }
            }
        }
        
        stage('Deploy to Production') {
            agent any
            steps {
                echo "ðŸš€ Starting deployment to production server..."
                withCredentials([
                    sshUserPrivateKey(credentialsId: 'do-ssh-key', keyFileVariable: 'SSH_KEY'),
                    string(credentialsId: 'mongo-prod-uri', variable: 'MONGO_URI'),
                    string(credentialsId: 'jwt-secret', variable: 'JWT_SECRET'),
                    string(credentialsId: 'api-port', variable: 'API_PORT'),
                    string(credentialsId: 'web-port', variable: 'WEB_PORT'),
                    string(credentialsId: 'mailtrap-token', variable: 'MAILTRAP_TOKEN'),
                    string(credentialsId: 'upload-url', variable: 'UPLOAD_URL')
                ]) {
                   sh """
    ssh -o StrictHostKeyChecking=no -i \$SSH_KEY ${env.DROPLET_USER}@${env.DROPLET_IP} '
        cd /app && 
        git fetch origin && 
        git reset --hard origin/main && 
        
        # Export all environment variables
        export TAG=${env.BUILD_NUMBER}
        export MONGO_URI="${MONGO_URI}"
        export JWT_SECRET="${JWT_SECRET}"
        export API_PORT="${API_PORT}"
        export WEB_PORT="${WEB_PORT}"
        export MAILTRAP_TOKEN="${MAILTRAP_TOKEN}"
        export UPLOAD_URL="${UPLOAD_URL}"
        export NODE_ENV=production
        
        # Create .env file for production
        cat > .env.prod << EOF
MONGO_URI=${MONGO_URI}
JWT_SECRET=${JWT_SECRET}
API_PORT=${API_PORT}
WEB_PORT=${WEB_PORT}
MAILTRAP_TOKEN=${MAILTRAP_TOKEN}
UPLOAD_URL=${UPLOAD_URL}
NODE_ENV=production
TAG=${env.BUILD_NUMBER}
EOF
        
        # Deploy using docker-compose
        docker-compose -f docker-compose.prod.yml pull && 
        docker-compose -f docker-compose.prod.yml --env-file .env.prod up -d --remove-orphans && 
        
        echo "â³ Waiting for services to start..." && 
        sleep 10 && 
        
        docker ps && 
        
        echo "ðŸ¥ Checking API health..." && 
        curl -f http://localhost:\${API_PORT}/health || exit 1 && 
        echo "âœ… API is healthy!" && 
        
        echo "ðŸ¥ Checking Web health..." && 
        curl -f http://localhost:\${WEB_PORT} || exit 1 && 
        echo "âœ… Web is healthy!"
    '
"""
                }
                echo "âœ… Production deployment completed successfully!"
            }
        }
        
        stage('Post-Deploy Verification') {
            agent any
            steps {
                echo "ðŸ” Verifying deployment..."
                withCredentials([
                    string(credentialsId: 'vite-api-url', variable: 'VITE_API_URL'),
                    string(credentialsId: 'web-public-url', variable: 'WEB_PUBLIC_URL')
                ]) {
                    sh """
                        echo "Testing API endpoint..."
                        curl -f ${VITE_API_URL}/health || exit 1
                        
                        echo "Testing Web endpoint..."
                        curl -f ${WEB_PUBLIC_URL} || exit 1
                        
                        echo "âœ… All endpoints responding!"
                    """
                }
            }
        }
    }
    
    post {
        success {
            echo 'âœ… Pipeline completed successfully!'
        }
        failure {
            echo 'âŒ Pipeline failed! Check the logs.'
        }
        always {
            node('built-in') {
                echo 'ðŸ§¹ Cleaning up...'
                sh 'docker system prune -f || true'
            }
        }
    }
}