import React, { useState, useRef, useEffect } from 'react';
import axios from 'axios';
import { useApolloClient } from '@apollo/client';
import { useAuth } from '../../contexts/AuthContext';
import MediaPreview from './MediaPreview';
import MediaButtons from './MediaButtons';
import LocationDisplay from '../Location/LocationDisplay';
// We only need to import the hooks and types generated by the codegen.
import {
  useCreatePostMutation,
  GetPostsDocument,
  GetPostsQuery,
} from '../../gql/generated';

interface LocationResult {
  name: string;
  address: string;
  lat: number;
  lng: number;
  placeId: string;
}

export function CreatePost() {
  const [content, setContent] = useState('');
  const [previews, setPreviews] = useState<string[]>([]);
  const [selectedImage, setSelectedImage] = useState<File | null>(null);
  const [selectedVideo, setSelectedVideo] = useState<File | null>(null);
  const [selectedLocation, setSelectedLocation] = useState<LocationResult | null>(null);
  const [isLocationSearchOpen, setIsLocationSearchOpen] = useState(false);
  const [uploading, setUploading] = useState(false);
  const [isExpanded, setIsExpanded] = useState(false);
  const imageInputRef = useRef<HTMLInputElement>(null);
  const videoInputRef = useRef<HTMLInputElement>(null);
  const createPostRef = useRef<HTMLDivElement>(null);
  const apolloClient = useApolloClient();
  const { user } = useAuth();
  const maxCaptionLength = 500;

  // Add animation styles
  useEffect(() => {
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    `;
    document.head.appendChild(style);
    return () => {
      document.head.removeChild(style);
    };
  }, []);

  // Handle click outside to collapse
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (createPostRef.current && !createPostRef.current.contains(event.target as Node) && isExpanded) {
        // Only collapse if there's no content to avoid losing work
        if (!content.trim() && !selectedImage && !selectedVideo && !selectedLocation) {
          handleCollapse();
        }
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isExpanded, content, selectedImage, selectedVideo, selectedLocation]);
  
  // The generated hook already knows what mutation to run.
  const [, { loading, error }] = useCreatePostMutation({
    update(cache, { data: mutationResult }) {
      const newPost = mutationResult?.createPost;
      if (!newPost) return;

      const existingData = cache.readQuery<GetPostsQuery>({
        query: GetPostsDocument,
      });

      if (existingData?.posts) {
        cache.writeQuery({
          query: GetPostsDocument,
          data: { posts: [newPost, ...existingData.posts] },
        });
      }
    }
  });

  const handleImageSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setSelectedImage(file);
      setSelectedVideo(null);
      const preview = URL.createObjectURL(file);
      setPreviews([preview]);
    }
  };

  const handleVideoSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setSelectedVideo(file);
      setSelectedImage(null);
      const preview = URL.createObjectURL(file);
      setPreviews([preview]);
    }
  };

  const removeMedia = () => {
    previews.forEach(preview => URL.revokeObjectURL(preview));
    setSelectedImage(null);
    setSelectedVideo(null);
    setPreviews([]);
    if (imageInputRef.current) imageInputRef.current.value = '';
    if (videoInputRef.current) videoInputRef.current.value = '';
  };

  const removeLocation = () => {
    setSelectedLocation(null);
  };

  const resetForm = () => {
    setContent('');
    removeMedia();
    setSelectedLocation(null);
    setIsLocationSearchOpen(false);
  };

  const handleCollapse = () => {
    setIsExpanded(false);
    resetForm();
  };

  // Clean up preview URLs on unmount
  React.useEffect(() => {
    return () => {
      previews.forEach(preview => URL.revokeObjectURL(preview));
    };
  }, []);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!content.trim() || loading || uploading) return;

    try {
      setUploading(true);
      
      // Create a REST endpoint for now since GraphQL file upload is complex
      const formData = new FormData();
      formData.append('content', content);
      if (selectedImage) {
        formData.append('images', selectedImage);
      } else if (selectedVideo) {
        formData.append('images', selectedVideo);
      }

      console.log('Uploading post with media');
      
      const token = localStorage.getItem('passport_buddy_token');
      const response = await axios.post(`${import.meta.env.VITE_API_URL}/api/posts`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
          'Authorization': token ? `Bearer ${token}` : '',
        },
      });

      console.log('Upload response:', response.data);

      // Update Apollo cache with the new post
      // Make sure the REST response matches GraphQL format
      const newPost = {
        ...response.data,
        __typename: 'Post' as const,
        images: response.data.images || []
      };
      
      const existingData = apolloClient.readQuery<GetPostsQuery>({
        query: GetPostsDocument,
      });

      console.log('Existing posts:', existingData?.posts.length);
      console.log('New post structure:', newPost);

      if (existingData?.posts) {
        // Filter out any invalid posts and add the new one
        const validPosts = existingData.posts.filter(p => p && p._id);
        apolloClient.writeQuery({
          query: GetPostsDocument,
          data: { 
            posts: [newPost, ...validPosts] 
          },
        });
        console.log('Cache updated successfully');
      } else {
        // If no existing data, create new cache entry
        apolloClient.writeQuery({
          query: GetPostsDocument,
          data: { 
            posts: [newPost] 
          },
        });
      }

      // Clear form and collapse
      handleCollapse();
    } catch (error) {
      console.error('Failed to create post:', error);
      if (axios.isAxiosError(error)) {
        console.error('Response:', error.response?.data);
        alert(`Failed to create post: ${error.response?.data?.message || error.message}`);
      } else {
        alert('Failed to create post');
      }
    } finally {
      setUploading(false);
    }
  };

  return (
    <div 
      ref={createPostRef}
      style={{ 
        backgroundColor: 'var(--pb-white)', 
        borderRadius: '12px', 
        padding: '0.75rem', 
        marginBottom: '1rem', 
        border: '1px solid var(--pb-light-periwinkle)',
        transition: 'all 0.2s ease',
        boxShadow: '0 1px 2px rgba(0, 0, 0, 0.04)'
      }}>
      <form onSubmit={handleSubmit}>
        <div style={{ display: 'flex', gap: '0.5rem' }}>
          <div style={{ 
            width: '2rem', 
            height: '2rem', 
            borderRadius: '50%', 
            overflow: 'hidden',
            backgroundColor: 'var(--pb-light-periwinkle)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            position: 'relative'
          }}>
            {user?.avatar ? (
              <img
                src={user.avatar}
                alt={user.username}
                style={{ 
                  width: '100%', 
                  height: '100%', 
                  objectFit: 'cover' 
                }}
              />
            ) : (
              <span style={{ 
                fontSize: '0.875rem', 
                fontWeight: '600',
                color: '#6b7280'
              }}>
                {user?.fullName?.charAt(0)?.toUpperCase() ||
                  user?.username?.charAt(0)?.toUpperCase() || "U"}
              </span>
            )}
          </div>

          <div style={{ flex: '1' }}>
            <div style={{ fontWeight: '600', color: '#000', fontSize: '0.813rem', marginBottom: '6px' }}>
              {user?.username || 'User'}
            </div>
            
            <textarea
              value={content}
              onChange={(e) => setContent(e.target.value)}
              placeholder="What's new?"
              onFocus={() => setIsExpanded(true)}
              style={{
                width: '100%',
                backgroundColor: 'transparent',
                border: 'none',
                outline: 'none',
                color: '#000',
                fontSize: '0.813rem',
                resize: 'none',
                minHeight: isExpanded ? '80px' : '32px',
                fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                lineHeight: '1.5',
                transition: 'min-height 0.2s ease'
              }}
              maxLength={maxCaptionLength}
              disabled={uploading}
            />

            {content.length > 400 && (
              <div style={{ textAlign: 'right', fontSize: '0.688rem', color: content.length > 450 ? '#ef4444' : '#9ca3af', marginTop: '0.25rem' }}>
                {content.length}/{maxCaptionLength}
              </div>
            )}

            <MediaPreview
              previewUrl={previews[0] || null}
              selectedImage={selectedImage}
              selectedVideo={selectedVideo}
              onRemoveMedia={removeMedia}
              isLoading={uploading}
            />

            {selectedLocation && (
              <LocationDisplay
                selectedCity={selectedLocation}
                onRemoveLocation={removeLocation}
                isLoading={uploading}
              />
            )}

            {isExpanded && (
              <>
                <MediaButtons
                  onImageClick={() => imageInputRef.current?.click()}
                  onVideoClick={() => videoInputRef.current?.click()}
                  onLocationClick={(e) => {
                    e.preventDefault();
                    setIsLocationSearchOpen(!isLocationSearchOpen);
                  }}
                  isLocationSearchOpen={isLocationSearchOpen}
                  selectedLocation={selectedLocation}
                  onLocationSelect={setSelectedLocation}
                  onLocationSearchClose={() => setIsLocationSearchOpen(false)}
                  onRemoveLocation={removeLocation}
                  isLoading={uploading}
                />

                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  marginTop: '0.75rem',
                  paddingTop: '0.75rem',
                  borderTop: '1px solid #f0f0f0'
                }}>
                  <div style={{ fontSize: '0.75rem', color: '#999' }}>
                    Anyone can reply
                  </div>
                  <div style={{ display: 'flex', gap: '0.5rem' }}>
                    <button
                      type="button"
                      onClick={handleCollapse}
                      style={{
                        padding: '0.375rem 0.75rem',
                        backgroundColor: 'transparent',
                        border: '1px solid #e0e0e0',
                        borderRadius: '16px',
                        color: '#666',
                        fontSize: '0.75rem',
                        fontWeight: '500',
                        cursor: 'pointer',
                        transition: 'all 0.2s ease'
                      }}
                    >
                      Cancel
                    </button>
                    <button
                      type="submit"
                      disabled={loading || uploading || (!content.trim() && !selectedImage && !selectedVideo)}
                      style={{
                        paddingLeft: '1rem',
                        paddingRight: '1rem',
                        paddingTop: '0.375rem',
                        paddingBottom: '0.375rem',
                        backgroundColor: loading || uploading || (!content.trim() && !selectedImage && !selectedVideo) ? '#f5f5f5' : '#000',
                        color: loading || uploading || (!content.trim() && !selectedImage && !selectedVideo) ? '#999' : '#fff',
                        borderRadius: '16px',
                        fontSize: '0.75rem',
                        fontWeight: '500',
                        border: 'none',
                        cursor: loading || uploading || (!content.trim() && !selectedImage && !selectedVideo) ? 'not-allowed' : 'pointer',
                        transition: 'all 0.2s ease'
                      }}
                      onMouseEnter={(e) => {
                        if (!loading && !uploading && (content.trim() || selectedImage || selectedVideo)) {
                          e.currentTarget.style.opacity = '0.85';
                        }
                      }}
                      onMouseLeave={(e) => {
                        e.currentTarget.style.opacity = '1';
                      }}
                    >
                      {uploading ? 'Uploading...' : loading ? 'Posting...' : 'Post'}
                    </button>
                  </div>
                </div>
              </>
            )}

            {/* Hidden File Inputs */}
            <input
              type="file"
              accept="image/*"
              style={{ display: 'none' }}
              ref={imageInputRef}
              onChange={handleImageSelect}
            />
            <input
              type="file"
              accept="video/*"
              style={{ display: 'none' }}
              ref={videoInputRef}
              onChange={handleVideoSelect}
            />
          </div>
        </div>

        {error && <p style={{ color: '#ef4444', fontSize: '0.75rem', marginTop: '0.375rem' }}>Error: {error.message}</p>}
      </form>
    </div>

  );
}